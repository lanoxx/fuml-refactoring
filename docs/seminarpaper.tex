\documentclass{llncs}

\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{verbatim}
\usepackage[lined,linesnumbered,algochapter]{algorithm2e}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{xspace}
\usepackage{todonotes}          % Package for working draft comments
\usepackage{hyperref}           % Package for hyperlink references in the document

\usepackage{ngerman}
\usepackage[ngerman, english]{babel}
\usepackage{bibgerm,cite}       % Deutsche Bezeichnungen, Automatisches Zusammenfassen von Literaturstellen
\usepackage[ngerman]{varioref}  % Querverweise

\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{3}

% define custom macros for specific formats or names
\newcommand{\uml}[1]{\texttt{#1}}
\newcommand{\cd}{\textsf{Class Diagram}}

\begin{document}
\pagestyle{plain}
\pagenumbering{roman}

\title{Refactoring UML models}
\author{Sebastian Geiger \and Kristof Meixner}
\institute{\email{sbastig@gmx.at} \\ Registration No. 1127054 \and \email{kristof.meixner@fatlenny.net} \\ Registration No. 9725208}

\maketitle

\begin{abstract}
Over the last twenty years refactoring advanced to a commonly known and used techniques in modern software engineering. We present an overview from the beginning of refactoring in source code to its actual application in model-driven software development. Furthermore we discuss methods that ensure that refactored source code is sill correct.
\end{abstract}

\tableofcontents
%\thispagestyle{plain}
\newpage

\pagenumbering{arabic}

\section{Introduction}
\label{sec:intro}

Model-based software development or model-driven software development is not only an extensive field of research but receives also more and more attention from the industry. Nowadays models are not only used as visual explanations of software concepts but as source for the development process itself. Thus models need to provide an abstraction of
the represented concepts in high quality. To provide quality assured software artifacts that last over the software lifecycle a technique called refactoring is often used to restructure in our case models. Refactorings should improve the quality and also the understandability of the models as well as adapt the models to changes coming from from the domain. The most important requirement for refactorings is that the preserve the behavior of the model. In our project work we focus on an set of refactorings that should be implemented taking the correlations between different model types as well as static and dynamic analysis into account. In this work we concentrate on the related work in a broader sense.

The paper is structured as follows. Section \ref{sec:beginning} copes with the early steps of refactoring in the domain of source code development. The following section discusses how commonly known refactorings from source code where adapted in theoretical works to models.

\section{Beginning in Refactoring}
\label{sec:beginning}

In this section we will present an overview on the beginnings in structured refactoring of source code. In his thesis \cite{mast:REFOOF} Opdyke ``defines a set of program restructuring operations'' that ``preserve the behavior of a program'' to increase software quality. This technique became known as refactoring.

The motivation of his work is on the one hand that software should be reused because of the high costs of development and on the other hand that software needs to be restructured over its lifecycle to maintain this reusability. The issue he addressed in his work is the problem of changing parts of source code from an object oriented system, grounded in a possibly large code base while also maintaining all the references and dependencies manually. He described this process as ``time consuming, difficult and error prone''. As a solution he proposes ``an approach for providing automated support for the restructuring'', plans to reorganize the source code on an intermediate level without changing the behavior of the program.

A section in the thesis covers behavior preserving approaches. In this chapter he first mentions the usage as ``preconditions'' to ensure that a refactoring does not corrupt the syntax and more important does not change the execution behavior of the program. He quickly refuses the approach to use the static compiler to test these issues as the compiler is not able to catch ``some errors that could change the behavior of the program''. In this section also some rules are presented that can be tested beforehand to check if a refactoring is possible on the concepts. A rule to highlight copes with semantic preservation of code and is described as ``Semantically Equivalent References and Operation''. He defines that semantic equivalence as follows: \textit{``let the external interface to the program be via the function main. If the function main is called twice (once before and once after a refactoring) with the same set of inputs, the resulting set of output values must be the same''}. This means that from outside of a specific system circle the refactoring is not visible. The range of this circle however differs from the impact of the refactoring on the system. In the rest of his work he shows some examples of refactorings depending on their level of implication for the source code for \textit{Smalltalk} program concepts and how they could be applied.

Roberts \cite{rob99}, writing his thesis on the same University, builds large parts of his contribution on the work of Opdyke. He criticizes that the refactorings described by Opdyke are to small and ``are rarely performed in isolation'' but in a sequence steps to refactor to a better ``design in mind''.  He also mentions that the ``expensive analysis'' for legal code after a refactoring should be eliminated and introduces postconditions along with Opdykes preconditions to guarantee behavior preservation. Besides his contribution of ``a formal definition of refactoring that is based on postconditions'' Roberts presents a dependency definition of refactorings that is based on the commutativity of single changed put in sequence. Furthermore issues an idea, which in our work seems rather interesting, to analyze very complex refactorings not in a static manner but dynamically via refactoring during execution. This in particular fits to our use case in the project that builds on executing and tracing changes due to refactoring before and after the modification. Roberts also redefines the refactorings developed by Opdyke and presents his catalog that can be used as a source for modern refactoring. 

Another extensive catalog of refactorings based on source code modifications in \textit{Java} was developed and described by Fowler in \cite{fow99}. His list of refactorings\footnote{The catalog can be found online under http://refactoring.com/catalog/} is continuously updated and extended for different programming language and shows also good examples how to refactor in design pattern thinking.

\section{From source code to model refactoring}
\label{sec:fromto}

In the last section we gave a brief introduction to the early research in refactoring. In this section we will discuss what model refactoring is and how it benefit from from source code refactoring. As already mentioned in Section \ref{sec:intro} modern software development more and more uses the concepts of model-based and model-driven approaches which means that formal models are one of the most important artifacts in development. This also implies that changes in the domain of the software have to be propagated to the formal models. With faster development cycles common in agile software development like eXtreme programming (\cite{DBLP:journals/computer/Beck99}) or Scrum (\cite{DBLP:journals/software/RisingJ00}) those changes have to be done even more efficient and reliable. It is obvious that in this case model development benefits from the techniques of refactoring introduced in the late nineties to source code. However models need to be treated a little different than source code.

Today the de-facto standard \textit{UML} (\cite{man:UML}) standardized by the \textit{OMG}\footnote{http://www.omg.org/} is used for model development. \textit{UML} consists of an abstract syntax which builds the foundations for the models which are formulated in the concrete syntax of the language. 

One of the first works in this domain was done by Suny{\'e} et al. in \cite{DBLP:conf/uml/SunyePTJ01}. They state that refactoring of models is difficult because ``it is often hard to measure the actual impact of modifications'' 

\newpage
\bibliographystyle{acm}
\bibliography{references}

\end{document}
